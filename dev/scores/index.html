<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Score Types · GerryChain</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GerryChain</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../getting_started/">Getting started with a chain</a></li><li><a class="tocitem" href="../graph/">BaseGraph</a></li><li><a class="tocitem" href="../partition/">Partition</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../accept/">Acceptance Functions</a></li><li><span class="tocitem">Scores</span><ul><li class="is-active"><a class="tocitem" href>Score Types</a><ul class="internal"><li><a class="tocitem" href="#Score-types"><span>Score types</span></a></li><li><a class="tocitem" href="#DistrictAggregate"><span><code>DistrictAggregate</code></span></a></li><li><a class="tocitem" href="#DistrictScore"><span><code>DistrictScore</code></span></a></li><li><a class="tocitem" href="#PlanScore"><span><code>PlanScore</code></span></a></li><li><a class="tocitem" href="#CompositeScore"><span><code>CompositeScore</code></span></a></li><li><a class="tocitem" href="#Built-In-Score-Functions"><span>Built-In Score Functions</span></a></li><li><a class="tocitem" href="#A-little-more-detail-on-score-functions"><span>A little more detail on score functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Other-Score-Functions"><span>Other Score Functions</span></a></li></ul></li><li><a class="tocitem" href="../chain_score_data/">ChainScoreData</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../saving_results/">Saving Results</a></li></ul></li><li><a class="tocitem" href="../election/">Election</a></li><li><a class="tocitem" href="../chains/">Markov Chains</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Scores</a></li><li class="is-active"><a href>Score Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Score Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mggg/GerryChainJulia/blob/master/docs/src/scores.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scores"><a class="docs-heading-anchor" href="#Scores">Scores</a><a id="Scores-1"></a><a class="docs-heading-anchor-permalink" href="#Scores" title="Permalink"></a></h1><p>Generally, the point of running the chain is comparing the properties of some existing plan to the properties of the ensemble of plans generated by the chain. Thus, we need a way to record information about the plans generated during the progression of the chain. This is the point of <code>Score</code>s: each score has a scoring function that is evaluated on the current districting plan at each step of the chain. The resulting values are saved in a dictionary, which is itself added to a growing <code>ChainScoreData</code> object at each step of the chain. The <code>ChainScoreData</code> returned by <code>recom_chain()</code> and <code>flip_chain()</code> is like a &quot;history&quot; of the scores at each step of the chain. (See <a href="../chain_score_data/#get_scores_at_step()">get_scores_at_step()</a> for information about how to retrieve the values of any subset of scores at a particular step in the chain.)</p><h2 id="Score-types"><a class="docs-heading-anchor" href="#Score-types">Score types</a><a id="Score-types-1"></a><a class="docs-heading-anchor-permalink" href="#Score-types" title="Permalink"></a></h2><p>All Scores have the type <code>AbstractScore</code>. There are four categories of scores (note that <code>DistrictAggregate</code> is really a sub-category of <code>DistrictScore</code>):</p><table><tr><th style="text-align: right">Score Type</th><th style="text-align: right">Fields</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>DistrictAggregate</code></td><td style="text-align: right"><code>name</code> (String), <code>key</code> (String)</td><td style="text-align: right">A DistrictAggregate score is a simple sum of a particular property over all nodes in a given district.</td></tr><tr><td style="text-align: right"><code>DistrictScore</code></td><td style="text-align: right"><code>name</code> (String), <code>score_fn</code> (Function)</td><td style="text-align: right">A <code>DistrictScore</code> takes a user-supplied function that returns some quantity of interest given the nodes in a given district. The signature of <code>score_fn</code> should be as follows: <code>score_fn(graph::BaseGraph, district_nodes::BitSet, district::int)</code></td></tr><tr><td style="text-align: right"><code>PlanScore</code></td><td style="text-align: right"><code>name</code> (String),  <code>score_fn</code> (Function)</td><td style="text-align: right">A PlanScore takes a user-supplied function that returns some quantity of interest given a BaseGraph and corresponding Partition object. The signature of <code>score_fn</code> should be as follows: <code>score_fn(graph::BaseGraph, partition::Partition)</code></td></tr><tr><td style="text-align: right"><code>CompositeScore</code></td><td style="text-align: right"><code>name</code> (String),  <code>scores</code> (Array{S, 1} where S&lt;:AbstractScore)</td><td style="text-align: right">A CompositeScore is just a group of scores that are run in sequence. CompositeScores are especially useful when the score functions depend upon/modify some shared state. The <code>Election</code> object is implemented as a <code>CompositeScore</code>.</td></tr></table><p>So, when should you use which score? Here&#39;s a general breakdown:</p><h2 id="DistrictAggregate"><a class="docs-heading-anchor" href="#DistrictAggregate"><code>DistrictAggregate</code></a><a id="DistrictAggregate-1"></a><a class="docs-heading-anchor-permalink" href="#DistrictAggregate" title="Permalink"></a></h2><p>Use this score when you just want to sum an attribute over all nodes in a district.</p><article class="docstring"><header><a class="docstring-binding" id="GerryChain.DistrictAggregate" href="#GerryChain.DistrictAggregate"><code>GerryChain.DistrictAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistrictAggregate(name::String,
                  key::String)</code></pre><p>A DistrictAggregate score is a simple sum of a particular property over all nodes in a given district.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L3-L9">source</a></section></article><p>For example, if you wanted to count the number of Black people in each district at every step of the chain, you could use a <code>DistrictAggregate</code> score to do so. If the attribute in the nodes of the graph was called &quot;BLACK&quot; and you wanted to call your score &quot;Black_Pop&quot;, you would initialize the score as</p><pre><code class="language-julia-repl">julia&gt; DistrictAggregate(&quot;Black_Pop&quot;, &quot;BLACK&quot;)
DistrictAggregate(&quot;Black_Pop&quot;, &quot;BLACK&quot;)</code></pre><p>If you wanted to name your score the same as the node attribute, you could also use</p><article class="docstring"><header><a class="docstring-binding" id="GerryChain.DistrictAggregate-Tuple{String}" href="#GerryChain.DistrictAggregate-Tuple{String}"><code>GerryChain.DistrictAggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DistrictAggregate(key::String)</code></pre><p>Initializes a DistrictAggregate score where the name and key are the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L86-L90">source</a></section></article><p>In this case, you would instantiate your score as</p><pre><code class="language-julia-repl">julia&gt; DistrictAggregate(&quot;BLACK&quot;)
DistrictAggregate(&quot;BLACK&quot;, &quot;BLACK&quot;)</code></pre><h2 id="DistrictScore"><a class="docs-heading-anchor" href="#DistrictScore"><code>DistrictScore</code></a><a id="DistrictScore-1"></a><a class="docs-heading-anchor-permalink" href="#DistrictScore" title="Permalink"></a></h2><p>This score works best when you&#39;re interested in tracking a statistic for each district for all plans in the chain. For example, you might want to know the <a href="https://en.wikipedia.org/wiki/Polsby%E2%80%93Popper_test">Polsby-Popper score</a> for each district at every step of the chain.</p><article class="docstring"><header><a class="docstring-binding" id="GerryChain.DistrictScore" href="#GerryChain.DistrictScore"><code>GerryChain.DistrictScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistrictScore(name::Union{String, Missing}
              score_fn::Function)</code></pre><p>A <code>DistrictScore</code> takes a user-supplied function that returns some quantity of interest given the nodes in a given district. The signature of <code>score_fn</code> should be as follows:     <code>score_fn(graph::BaseGraph, district_nodes::BitSet, district::int)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L15-L23">source</a></section></article><p>The example below illustrates a simple example of setting up a <code>DistrictScore</code>. Perhaps somehow you find yourself interested in computing the number of edges within a district.</p><pre><code class="language-julia-repl">julia&gt; function num_edges_within_dist(graph::BaseGraph,
                                      district_nodes::BitSet,
                                      district::Int)
           &quot;&quot;&quot; Computes the number of edges within each district of the plan.
               Arguments:
                   graph:          The underlying BaseGraph
                   district_nodes: A Set of nodes in district `district`. Each node
                                   is represented as an Int.
                   district:       Int representing the district
           &quot;&quot;&quot;
           all_edges = []
           for node in district_nodes, neighbor in graph.neighbors[node]
               if neighbor in district_nodes
                   edge = graph.adj_matrix[node, neighbor]
                   push!(all_edges, edge)
               end
           end
           return length(unique(all_edges))
       end
num_edges_within_dist (generic function with 1 method)

julia&gt; # instantiate this score
       DistrictScore(&quot;edges_within_dist&quot;, num_edges_within_dist)
DistrictScore(&quot;edges_within_dist&quot;, Main.ex-env.num_edges_within_dist)</code></pre><h2 id="PlanScore"><a class="docs-heading-anchor" href="#PlanScore"><code>PlanScore</code></a><a id="PlanScore-1"></a><a class="docs-heading-anchor-permalink" href="#PlanScore" title="Permalink"></a></h2><p>This type of score is suited to statistics that are evaluated on an entire plan. For example, the number of districts won by a party for a given plan would be a <code>PlanScore</code>.</p><article class="docstring"><header><a class="docstring-binding" id="GerryChain.PlanScore" href="#GerryChain.PlanScore"><code>GerryChain.PlanScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlanScore(name::Union{String, Missing},
          score_fn::Function)</code></pre><p>A <code>PlanScore</code> takes a user-supplied function that returns some quantity of interest given a <code>BaseGraph</code> and corresponding <code>Partition</code> object.</p><p>The signature of <code>score_fn</code> should be as follows:     <code>score_fn(graph::BaseGraph, partition::Partition)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L31-L40">source</a></section></article><p>Below we illustrate a few examples on how to construct a <code>PlanScore</code>:</p><pre><code class="language-julia-repl">julia&gt; function num_max_blocks(graph::BaseGraph,
                               partition::Partition)
           &quot;&quot;&quot; Returns the maximum number of blocks in each district.
               This function assumes that the nodes in `graph` are blocks.
           &quot;&quot;&quot;
           return maximum([length(nodes) for nodes in partition.dist_nodes])
       end
num_max_blocks (generic function with 1 method)

julia&gt; function higher_num_cut_edges_than_parent(graph::BaseGraph,
                                                 partition::Partition)
           &quot;&quot;&quot; Returns True if `partition` has a higher number of cut edges than the
               previous plan, False otherwise.
           &quot;&quot;&quot;
           if partition.parent isa Partition &amp; partition.num_cut_edges &gt; partition.parent.num_cut_edges
               return True
           end
           return False
       end
higher_num_cut_edges_than_parent (generic function with 1 method)

julia&gt; # how to formulate these scores
       PlanScore(&quot;num_max_blocks&quot;, num_max_blocks)
PlanScore(&quot;num_max_blocks&quot;, Main.ex-env.num_max_blocks)

julia&gt; PlanScore(&quot;higher_num_cut_edges_than_parent&quot;, higher_num_cut_edges_than_parent)
PlanScore(&quot;higher_num_cut_edges_than_parent&quot;, Main.ex-env.higher_num_cut_edges_than_parent)</code></pre><h2 id="CompositeScore"><a class="docs-heading-anchor" href="#CompositeScore"><code>CompositeScore</code></a><a id="CompositeScore-1"></a><a class="docs-heading-anchor-permalink" href="#CompositeScore" title="Permalink"></a></h2><p>This might be the most difficult type of score to wrap one&#39;s mind around. <code>CompositeScore</code>s are best when you have a series of scores with some shared state or rely on the same computation. They allow you to &quot;group&quot; scores together. For example, we use <code>CompositeScore</code>s for <code>Election</code>s, since almost all election-related scores rely on vote counts and vote shares.</p><article class="docstring"><header><a class="docstring-binding" id="GerryChain.CompositeScore" href="#GerryChain.CompositeScore"><code>GerryChain.CompositeScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CompositeScore(name::String,
               scores::Array{S,1}) where {S&lt;:AbstractScore} # should be other AbstractScores</code></pre><p>A <code>CompositeScore</code> is just a group of scores that are run in sequence. <code>CompositeScore</code>s are especially useful when the score functions depend upon/modify some shared state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L48-L55">source</a></section></article><h2 id="Built-In-Score-Functions"><a class="docs-heading-anchor" href="#Built-In-Score-Functions">Built-In Score Functions</a><a id="Built-In-Score-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Built-In-Score-Functions" title="Permalink"></a></h2><p>Currently only one score function comes built-in with <code>GerryChain</code>, and it is the number of cut-edges in the plan.</p><article class="docstring"><header><a class="docstring-binding" id="GerryChain.num_cut_edges" href="#GerryChain.num_cut_edges"><code>GerryChain.num_cut_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_cut_edges(name::String)::PlanScore</code></pre><p>Returns a <code>PlanScore</code> that tracks the number of cut edges in a particular plan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L707-L711">source</a></section></article><h2 id="A-little-more-detail-on-score-functions"><a class="docs-heading-anchor" href="#A-little-more-detail-on-score-functions">A little more detail on score functions</a><a id="A-little-more-detail-on-score-functions-1"></a><a class="docs-heading-anchor-permalink" href="#A-little-more-detail-on-score-functions" title="Permalink"></a></h2><p>Why do we differentiate between the different types of scores? The answer boils down to efficiency. Recall that each plan in the chain (whether it is uses   ReCom proposals or Flip proposals) only differs from the previous plan by 2 districts. This means we can save space / eliminate redundant computation by only re-calculating district-level scores on the districts that were changed. However, for plan-level scores, we always have to re-run the score function on the entire partition.</p><h1 id="Other-Score-Functions"><a class="docs-heading-anchor" href="#Other-Score-Functions">Other Score Functions</a><a id="Other-Score-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Score-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GerryChain.coerce_aggregated_attributes!-Union{Tuple{S}, Tuple{BaseGraph,Array{S,1}}} where S&lt;:AbstractScore" href="#GerryChain.coerce_aggregated_attributes!-Union{Tuple{S}, Tuple{BaseGraph,Array{S,1}}} where S&lt;:AbstractScore"><code>GerryChain.coerce_aggregated_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coerce_aggregated_attributes!(graph::BaseGraph,
                              scores::Array{S, 1}) where {S&lt;:AbstractScore}</code></pre><p>Coerces DistrictAggregate attributes in <code>scores</code> to be Floats if they are Strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L740-L746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.eval_score_on_district-Tuple{BaseGraph,Partition,DistrictAggregate,Int64}" href="#GerryChain.eval_score_on_district-Tuple{BaseGraph,Partition,DistrictAggregate,Int64}"><code>GerryChain.eval_score_on_district</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_score_on_district(graph::BaseGraph,
                       partition::Partition,
                       score::DistrictAggregate,
                       district::Int)::Number</code></pre><p>Evaluates a <code>DistrictAggregate</code> score on the nodes in a particular <code>district</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L150-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.eval_score_on_district-Tuple{BaseGraph,Partition,DistrictScore,Int64}" href="#GerryChain.eval_score_on_district-Tuple{BaseGraph,Partition,DistrictScore,Int64}"><code>GerryChain.eval_score_on_district</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_score_on_district(graph::BaseGraph,
                       partition::Partition,
                       score::DistrictScore,
                       district::Int)</code></pre><p>Evaluates a user-supplied <code>DistrictScore</code> function on the nodes in a particular <code>district</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L183-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,CompositeScore}" href="#GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,CompositeScore}"><code>GerryChain.eval_score_on_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_score_on_partition(graph::BaseGraph,
                        partition::Partition,
                        composite::CompositeScore)</code></pre><p>Evaluates the user-supplied functions in the <code>CompositeScore</code> scores array on each of the districts in the partition.</p><p>Returns an Dict of the form:</p><pre><code class="language-json">{
    # District-level scores
    d\_score₁.name :     [a₁, a₂, ..., aᵢ]
        ...
    d\_scoreᵤ.name :     [b₁, b₂, ..., bᵢ]
    # Partition-level scores
    p\_score₁.name :     c,
        ...
    p\_scoreᵥ.name :     d,
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L229-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,PlanScore}" href="#GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,PlanScore}"><code>GerryChain.eval_score_on_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_score_on_partition(graph::BaseGraph,
                        partition::Partition,
                        score::PlanScore)</code></pre><p>Evaluates a user-supplied <code>PlanScore</code> function on the entire partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L274-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,Union{DistrictAggregate, DistrictScore}}" href="#GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,Union{DistrictAggregate, DistrictScore}}"><code>GerryChain.eval_score_on_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluates a user-supplied <code>DistrictScore</code> function or <code>DistrictAggregate</code> score on  all districts in an entire plan.</p><p><em>Returns</em> an array of the form [a₁, a₂, ..., aᵢ], where <code>i</code> is the number of districts in the plan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.score_initial_partition-Union{Tuple{S}, Tuple{BaseGraph,Partition,Array{S,1}}} where S&lt;:AbstractScore" href="#GerryChain.score_initial_partition-Union{Tuple{S}, Tuple{BaseGraph,Partition,Array{S,1}}} where S&lt;:AbstractScore"><code>GerryChain.score_initial_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">score_initial_partition(graph::BaseGraph,
                        partition::Partition,
                        scores::Array{S, 1}) where {S&lt;:AbstractScore}</code></pre><p>Returns a dictionary of scores for the initial partition. The dictionary has the following form (where <code>n</code> is the number of districts, <code>u</code> is the number of district-level scores, <code>v</code> is the number of partition-level scores, and <code>i</code> is the number of composite scores):</p><pre><code class="language-json">{
    # District-level scores
    d\_score₁.name :     [a₁, a₂, ..., aᵤ]
        ...
    d\_scoreᵤ.name :     [b₁, b₂, ..., bᵤ]
    # Partition-level scores
    p\_score₁.name :     c,
        ...
    p\_scoreᵥ.name :     d,
    # Composite scores
    c\_score₁.name :
        {
            c\_score₁.scores[1].name :     ...
                ...
        }
        ...
    c\_scoreᵢ.name :
        {
            ...
        }
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L296-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GerryChain.score_partition_from_proposal-Union{Tuple{S}, Tuple{BaseGraph,Partition,GerryChain.AbstractProposal,Array{S,1}}} where S&lt;:AbstractScore" href="#GerryChain.score_partition_from_proposal-Union{Tuple{S}, Tuple{BaseGraph,Partition,GerryChain.AbstractProposal,Array{S,1}}} where S&lt;:AbstractScore"><code>GerryChain.score_partition_from_proposal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">score_partition_from_proposal(graph::BaseGraph,
                              partition::Partition,
                              proposal::AbstractProposal,
                              scores::Array{S, 1}) where {S&lt;:AbstractScore}</code></pre><p>Returns a Dictionary of</p><ul><li>(a) updated district-level scores for districts that were altered</li></ul><p>after <code>proposal</code> was accepted,</p><ul><li>(b) partition-level scores, and</li></ul><p>(c) composite scores, that may be comprised of scores from (a) or (b).</p><p>For example, suppose district 4&#39;s new White population is 43 and the new Sen2010_Dem population is 62, district 8&#39;s new White population is 22 and new Sen2010_Dem population is 66. The Δ scores would look like:</p><pre><code class="language-json">    {
        &quot;num_cut_edges&quot; : partition.num\_cut\_edges,
        &quot;dists&quot;         : (5, 8),
        &quot;White&quot;         : [43, 22],
        &quot;Sen2010_Dem&quot;   : [62, 66],
    }</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mggg/GerryChainJulia/blob/489f9c37da65913823f235d4c178fb5feeb54988/src/scores.jl#L343-L367">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../accept/">« Acceptance Functions</a><a class="docs-footer-nextpage" href="../chain_score_data/">ChainScoreData »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 October 2020 16:51">Friday 23 October 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
