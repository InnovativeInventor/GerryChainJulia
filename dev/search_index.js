var documenterSearchIndex = {"docs":
[{"location":"chain_score_data/#ChainScoreData","page":"ChainScoreData","title":"ChainScoreData","text":"","category":"section"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"The purpose of the ChainScoreData object is reflected in its name: its purpose is to store data about the values of scores throughout the entire history of the Markov chain. You can think of it as containing an Array of Dict objects, where each element in the array is a Dict that corresponds to one state of the chain. In turn, each Dict contains keys for every AbstractScore passed to the chain by the user, and the values of the Dict are the values of the scoring functions, evaluated on a particular plan in the chain.","category":"page"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"Order = [:type, :function]\nPages   = [\"chain_score_data.md\"]","category":"page"},{"location":"chain_score_data/#get_scores_at_step()","page":"ChainScoreData","title":"get_scores_at_step()","text":"","category":"section"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"get_scores_at_step","category":"page"},{"location":"chain_score_data/#GerryChain.get_scores_at_step","page":"ChainScoreData","title":"GerryChain.get_scores_at_step","text":"get_scores_at_step(chain_data::ChainScoreData,\n                   step::Int;\n                   score_names::Array{String,1}=String[])::Dict{String, Any}\n\nReturns the detailed scores of the partition at step step. If no scores are passed in, all scores are returned by default. Here, step=0 represents the score of the original (initial) partition, so step=t will return the scores of the plan that was produced after taking t steps of the Markov chain.\n\nArguments:\n\nchain_data   : ChainScoreData object containing scores of partitions                at each step of the Markov Chain\nstep         : The step of the chain at which scores are desired\nscore_names  : An optional array of Strings representing the scores                for which the user is requesting the values\n\n\n\n\n\n","category":"function"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"recom_chain or flip_chain returns a ChainScoreData object. If you want to know what the values of any/all scores were at a particular step in the chain, use get_scores_at_step. This will return a Dict{String, Any} from the name of the score to its value at step step. If no scores are passed in, all scores are returned by default. Here, step=0 represents the score of the original (initial) partition, so step=t will return the scores of the plan that was produced after taking t steps of the Markov chain.","category":"page"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"Running get_scores_at_step() for different score types would get you different kinds of return values:","category":"page"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"Running get_scores_at_step(chain_data, step, \"name_of_district_aggregate_score\") would return an Array of length d, where d is the number of districts.\nRunning get_scores_at_step(chain_data, step, \"name_of_district_score\") would return an Array of length d, where d is the number of districts.\nRunning get_scores_at_step(chain_data, step, \"name_of_plan_score\") would return a single value, representing the value of the PlanScore for the plan at step step.","category":"page"},{"location":"chain_score_data/#get_score_values()","page":"ChainScoreData","title":"get_score_values()","text":"","category":"section"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"get_score_values(::ChainScoreData,\n                 ::String)","category":"page"},{"location":"chain_score_data/#GerryChain.get_score_values-Tuple{ChainScoreData,String}","page":"ChainScoreData","title":"GerryChain.get_score_values","text":"get_score_values(chain_data::ChainScoreData,\n                 score_name::String)\n\nReturns the value of specified score at every step of the chain.\n\nArguments:\n\nchain_data   : ChainScoreData object containing scores of partitions                at each step of the Markov Chain\nscore_name   : Name of the score of interest\n\n\n\n\n\n","category":"method"},{"location":"chain_score_data/","page":"ChainScoreData","title":"ChainScoreData","text":"If you want to query the ChainScoreData for all values of a particular score throughout the history of the chain, use get_score_values. It will return an array of values where each element of the array corresponds to the value of the score at step i of the chain.","category":"page"},{"location":"chains/#Markov-Chains","page":"Markov Chains","title":"Markov Chains","text":"","category":"section"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"The following methods are used to \"run\" the chain; i.e., initiate the process of sequentially generating and evaluating districting plans.","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"We highly recommend using the ReCom plan proposal method.","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"You can think of the chain as a loop that progresses like this:","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"(generate proposal for new plan that fits within constraints ➡ decide whether to accept the proposal ➡ update partition to reflect new districting plan ➡ record value of scores on the new plan) x num_steps.","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"Order = [:type, :function]\nPages   = [\"chains.md\"]","category":"page"},{"location":"chains/#ReCom-Chain","page":"Markov Chains","title":"ReCom Chain","text":"","category":"section"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"Runs a Markov Chain for num_steps steps using ReCom. In summary, the ReCom proposal method works as follows: merge two districts in the plan, generate a minimum spanning tree for the precincts in the merged district, then \"split\" the merged district into two new districts by finding a population-balanced cut of the MST. This method could potentially be used to merge/split an arbitrary number of districts, but currently, our implementation only supports merging 2 districts and splitting into 2 new districts.","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"recom_chain","category":"page"},{"location":"chains/#GerryChain.recom_chain","page":"Markov Chains","title":"GerryChain.recom_chain","text":"recom_chain(graph::BaseGraph,\n            partition::Partition,\n            pop_constraint::PopulationConstraint,\n            num_steps::Int,\n            scores::Array{S, 1};\n            num_tries::Int=3,\n            acceptance_fn::F=always_accept,\n            rng::AbstractRNG=Random.default_rng(),\n            no_self_loops::Bool=false)::ChainScoreData where {F<:Function, S<:AbstractScore}\n\nRuns a Markov Chain for num_steps steps using ReCom. Returns a ChainScoreData object which can be queried to retrieve the values of every score at each step of the chain.\n\nArguments:\n\ngraph:            BaseGraph\npartition:        Partition with the plan information\npop_constraint:   PopulationConstraint\nnum_steps:        Number of steps to run the chain for\nscores:           Array of AbstractScores to capture at each step\nnum_tries:        num times to try getting a balanced cut from a subgraph                   before giving up\nacceptance_fn:    A function generating a probability in [0, 1]                   representing the likelihood of accepting the                   proposal. Should accept a Partition as input.\nrng:              Random number generator. The user can pass in their                   own; otherwise, we use the default RNG from Random.\nno_self_loops: If this is true, then a failure to accept a new state                   is not considered a self-loop; rather, the chain                   simply generates new proposals until the acceptance                   function is satisfied. BEWARE - this can create                   infinite loops if the acceptance function is never                   satisfied!\n\n\n\n\n\n","category":"function"},{"location":"chains/#Flip-chain","page":"Markov Chains","title":"Flip chain","text":"","category":"section"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"The flip_chain method is quite similar to the recom_chain method. The only difference is how new plans are generated at each step of the chain. Out of the set of cut edges in a given plan, where a cut edge is defined to be an edge in the dual graph that crosses from a node in one district to a node in a different district, one cut edge is randomly selected, and one of the two precincts is \"flipped\" to the district of the other precinct.","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"Runs a Markov Chain for num_steps steps using Flip proposals.","category":"page"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"flip_chain","category":"page"},{"location":"chains/#GerryChain.flip_chain","page":"Markov Chains","title":"GerryChain.flip_chain","text":"flip_chain(graph::BaseGraph,\n           partition::Partition,\n           pop_constraint::PopulationConstraint,\n           cont_constraint::ContiguityConstraint,\n           num_steps::Int,\n           scores::Array{S, 1};\n           acceptance_fn::F=always_accept,\n           no_self_loops::Bool=false)::ChainScoreData where {F<:Function, S<:AbstractScore}\n\nRuns a Markov Chain for num_steps steps using Flip proposals. Returns a ChainScoreData object which can be queried to retrieve the values of every score at each step of the chain.\n\nArguments:\n\ngraph:              BaseGraph\npartition:          Partition with the plan information\npop_constraint:     PopulationConstraint\ncont_constraint:    ContiguityConstraint\nnum_steps:          Number of steps to run the chain for\nscores:             Array of AbstractScores to capture at each step\nacceptance_fn:      A function generating a probability in [0, 1]                     representing the likelihood of accepting the                     proposal\nno_self_loops:  If this is true, then a failure to accept a new state                     is not considered a self-loop; rather, the chain                     simply generates new proposals until the acceptance                     function is satisfied. BEWARE - this can create                     infinite loops if the acceptance function is never                     satisfied!\n\n\n\n\n\n","category":"function"},{"location":"chains/#API","page":"Markov Chains","title":"API","text":"","category":"section"},{"location":"chains/","page":"Markov Chains","title":"Markov Chains","text":"Modules = [GerryChain]\nPages   = [\"recom.jl\", \"flip.jl\"]\nPrivate = false\nFilter = t -> t != recom_chain && t != flip_chain","category":"page"},{"location":"chains/#GerryChain.update_partition!","page":"Markov Chains","title":"GerryChain.update_partition!","text":"update_partition!(partition::Partition,\n                  graph::BaseGraph,\n                  proposal::RecomProposal,\n                  copy_parent::Bool=false)\n\nUpdates the Partition with the RecomProposal.\n\n\n\n\n\n","category":"function"},{"location":"chains/#GerryChain.update_partition!-2","page":"Markov Chains","title":"GerryChain.update_partition!","text":"update_partition!(partition::Partition,\n                  graph::BaseGraph,\n                  proposal::FlipProposal,\n                  copy_parent::Bool=false)\n\nUpdates the Partition with the FlipProposal.\n\n\n\n\n\n","category":"function"},{"location":"installation/#Installations","page":"Installation","title":"Installations","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you haven't already installed Julia, first order of business is to get that set up.","category":"page"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install Julia. You can find a link to the appropriate installer at","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"https://julialang.org/downloads/.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Check to make sure you can run Julia from the command line.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open up a Terminal/Command Prompt and type julia and press Enter. If this results in an error instead of the Julia interpreter, there may be a PATH issue. You can find official instructions on how to add Julia to your PATH at this page. (N.B. If you are using Windows, the full path you should be adding to your path should look something like this: C:\\Users\\[username]\\AppData\\Local\\Programs\\Julia\\Julia-[version]\\bin.)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install a code editor. For development in Julia, we recommend Juno,","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"which requires the installation of Atom. You can find instructions on the steps to install Juno here.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Check that you can run the Julia REPL in Atom. Open Atom and then","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"click Juno > Open REPL.  If you see an error, you may need to navigate to Juno > Settings and change the Julia Path to the appropriate location. This should allow you start the Julia interpreter from the REPL.","category":"page"},{"location":"installation/#Setting-up-the-GerryChain-environment","page":"Installation","title":"Setting up the GerryChain environment","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"We highly recommend you use a virtual environment for development in your projects. Virtual Environments can be easily set up using Julia's builtin package manager Pkg.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Type julia into your command line to start the julia interpreter.\nType using Pkg; Pkg.activate(\"NameOfEnvironment\"; shared=true) .","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This creates a virtual environment with the name NameOfEnvironment (you should pick a snazzier name!).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Type Pkg.add(\"GerryChain\"). After the package has been installed you can","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"exit out of the interpreter by typing exit(). You have successfully installed GerryChain in your virtual environment!","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Optional: If you want to code on Jupyter Notebook, also type in","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pkg.add(\"IJulia\") on the julia console. Next time you do jupyter notebook, you will see an option under the New tab to start a Julia notebook.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"When you run a script or want to use GerryChain through Jupyter notebooks,","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"you will want to start your script/notebook with","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.activate(\"NameOfEnvironment\"; shared=true)\nusing GerryChain","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You are all set to go!","category":"page"},{"location":"election/#Election","page":"Election","title":"Election","text":"","category":"section"},{"location":"election/","page":"Election","title":"Election","text":"Unsurprisingly, a key use of GerryChain is to analyze the electoral outcomes under different districting plans. If you wanted to, you could write a bunch of AbstractScores to measure election outcomes - or you could use the API we've already made for you!","category":"page"},{"location":"election/","page":"Election","title":"Election","text":"Order = [:type, :function]\nPages   = [\"election.md\"]","category":"page"},{"location":"election/","page":"Election","title":"Election","text":"Once initialized, the properties you can access in the Election struct are:","category":"page"},{"location":"election/#Properties","page":"Election","title":"Properties","text":"","category":"section"},{"location":"election/","page":"Election","title":"Election","text":"Field Description\nname (String) name of the Election\nparties (Array{String, 1}) array of names of different parties\nvote_counts (Array{Int64, 2}) matrix of vote counts (row = district, column = party)\nvote_shares (Array{Float64, 2}) matrix of vote shares (row = district, column = party)","category":"page"},{"location":"election/","page":"Election","title":"Election","text":"The way to initialize the Election object would be","category":"page"},{"location":"election/","page":"Election","title":"Election","text":"Election","category":"page"},{"location":"election/#GerryChain.Election","page":"Election","title":"GerryChain.Election","text":"Election(name::String,\n         parties::Array{String, 1},\n         num_districts::Int)\n\nInitializes an Election for a given number of parties and districts, initializing the vote counts & shares to zero.\n\n\n\n\n\n","category":"type"},{"location":"election/#ElectionTracker","page":"Election","title":"ElectionTracker","text":"","category":"section"},{"location":"election/","page":"Election","title":"Election","text":"The ElectionTracker method returns a CompositeScore that first updates the vote count / share for changed districts and then proceeds to calculate other partisan metrics, as desired by the user. Re-calculating vote counts only for changed districts means that the CompositeScore does not perform redundant computations for all of the partisan metrics.","category":"page"},{"location":"election/","page":"Election","title":"Election","text":"ElectionTracker","category":"page"},{"location":"election/#GerryChain.ElectionTracker","page":"Election","title":"GerryChain.ElectionTracker","text":"ElectionTracker(election::Election,\n                scores::Array{S, 1}=AbstractScore[])::CompositeScore where {S <: AbstractScore}\n\nThe ElectionTracker method returns a CompositeScore that first updates the vote count / share for changed districts and then proceeds to run other scores (such as vote count for a particular party, partisan metrics, etc.), as desired by the user. Re-calculating vote counts only for changed districts means that the CompositeScore does not perform redundant computations for all of the partisan metrics. Furthermore, packaging all election-related scores within the CompositeScore ensures that the vote update occurs first, followed by the partisan metrics scoring functions.\n\n\n\n\n\n","category":"function"},{"location":"election/#Election-related-metrics","page":"Election","title":"Election-related metrics","text":"","category":"section"},{"location":"election/","page":"Election","title":"Election","text":"Modules = [GerryChain]\nPages   = [\"election.jl\"]\nPrivate = false\nFilter = t -> t != ElectionTracker && t != Election","category":"page"},{"location":"election/#GerryChain.efficiency_gap-Tuple{String,Election,String}","page":"Election","title":"GerryChain.efficiency_gap","text":"efficiency_gap(name::String,\n               election::Election,\n               party::String)::PlanScore\n\nReturns a PlanScore with a custom scoring function specific to election that calculates the efficiency gap of a particular plan for a particular party.\n\n\n\n\n\n","category":"method"},{"location":"election/#GerryChain.mean_median-Tuple{String,Election,String}","page":"Election","title":"GerryChain.mean_median","text":"mean_median(name::String,\n            election::Election,\n            party::String)::PlanScore\n\nReturns a PlanScore with a custom scoring function specific to election that calculates the mean-median score of a particular plan for a particular party.\n\n\n\n\n\n","category":"method"},{"location":"election/#GerryChain.seats_won-Tuple{String,Election,String}","page":"Election","title":"GerryChain.seats_won","text":"seats_won(name::String,\n          election::Election,\n          party::String)::PlanScore\n\nReturns a PlanScore with a custom scoring function specific to election that returns the number of seats won by a particular party across all districts in a given plan.\n\n\n\n\n\n","category":"method"},{"location":"election/#GerryChain.vote_count-Tuple{String,Election,String}","page":"Election","title":"GerryChain.vote_count","text":"vote_count(name::String,\n           election::Election,\n           party::String)::DistrictScore\n\nReturns a DistrictScore that will return the number of votes won by the specified party.\n\n\n\n\n\n","category":"method"},{"location":"election/#GerryChain.vote_share-Tuple{String,Election,String}","page":"Election","title":"GerryChain.vote_share","text":"vote_share(name::String,\n           election::Election,\n           party::String)::DistrictScore\n\nReturns a DistrictScore that will return the percentage of votes won by the specified party.\n\n\n\n\n\n","category":"method"},{"location":"election/#GerryChain.wasted_votes-Tuple{Int64,Int64}","page":"Election","title":"GerryChain.wasted_votes","text":"wasted_votes(party₁_votes::Int,\n             party₂_votes::Int)\n\nComputes the number of votes \"wasted\" by each party. Wasted votes are votes that are either more than necessary than the party needed to win a seat or votes in a race that party lost. In a tie, all votes are considered to have been wasted.\n\n\n\n\n\n","category":"method"},{"location":"election/#Usage","page":"Election","title":"Usage","text":"","category":"section"},{"location":"election/","page":"Election","title":"Election","text":"election = Election(\"SEN10\", [\"SEN10D\", \"SEN10R\"], partition.num_dists)\nelection_metrics = [   # optional\n    vote_count(\"count_d\", election, \"SEN10D\"),\n    vote_share(\"share_d\", election, \"SEN10D\"),\n    efficiency_gap(\"efficiency_gap\", election, \"SEN10D\"),\n    seats_won(\"seats_won\", election, \"SEN10D\"),\n]\n...\nscores = [\n    ...\n    ElectionTracker(election, election_metrics)\n    ...\n]\n...\nchain_data = recom_chain(graph, partition, population_constraint, num_steps, scores)","category":"page"},{"location":"scores/#Scores","page":"Score Types","title":"Scores","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Generally, the point of running the chain is comparing the properties of some existing plan to the properties of the ensemble of plans generated by the chain. Thus, we need a way to record information about the plans generated during the progression of the chain. This is the point of Scores: each score has a scoring function that is evaluated on the current districting plan at each step of the chain. The resulting values are saved in a dictionary, which is itself added to a growing ChainScoreData object at each step of the chain. The ChainScoreData returned by recom_chain() and flip_chain() is like a \"history\" of the scores at each step of the chain. (See get_scores_at_step() for information about how to retrieve the values of any subset of scores at a particular step in the chain.)","category":"page"},{"location":"scores/#Score-types","page":"Score Types","title":"Score types","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"All Scores have the type AbstractScore. There are four categories of scores (note that DistrictAggregate is really a sub-category of DistrictScore):","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Score Type Fields Description\nDistrictAggregate name (String), key (String) A DistrictAggregate score is a simple sum of a particular property over all nodes in a given district.\nDistrictScore name (String), score_fn (Function) A DistrictScore takes a user-supplied function that returns some quantity of interest given the nodes in a given district. The signature of score_fn should be as follows: score_fn(graph::BaseGraph, district_nodes::BitSet, district::int)\nPlanScore name (String),  score_fn (Function) A PlanScore takes a user-supplied function that returns some quantity of interest given a BaseGraph and corresponding Partition object. The signature of score_fn should be as follows: score_fn(graph::BaseGraph, partition::Partition)\nCompositeScore name (String),  scores (Array{S, 1} where S<:AbstractScore) A CompositeScore is just a group of scores that are run in sequence. CompositeScores are especially useful when the score functions depend upon/modify some shared state. The Election object is implemented as a CompositeScore.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"using GerryChain","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"So, when should you use which score? Here's a general breakdown:","category":"page"},{"location":"scores/#DistrictAggregate","page":"Score Types","title":"DistrictAggregate","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Use this score when you just want to sum an attribute over all nodes in a district.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"DistrictAggregate","category":"page"},{"location":"scores/#GerryChain.DistrictAggregate","page":"Score Types","title":"GerryChain.DistrictAggregate","text":"DistrictAggregate(name::String,\n                  key::String)\n\nA DistrictAggregate score is a simple sum of a particular property over all nodes in a given district.\n\n\n\n\n\n","category":"type"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"For example, if you wanted to count the number of Black people in each district at every step of the chain, you could use a DistrictAggregate score to do so. If the attribute in the nodes of the graph was called \"BLACK\" and you wanted to call your score \"Black_Pop\", you would initialize the score as","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"DistrictAggregate(\"Black_Pop\", \"BLACK\")","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"If you wanted to name your score the same as the node attribute, you could also use","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"DistrictAggregate(::String)","category":"page"},{"location":"scores/#GerryChain.DistrictAggregate-Tuple{String}","page":"Score Types","title":"GerryChain.DistrictAggregate","text":"DistrictAggregate(key::String)\n\nInitializes a DistrictAggregate score where the name and key are the same.\n\n\n\n\n\n","category":"method"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"In this case, you would instantiate your score as","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"DistrictAggregate(\"BLACK\")","category":"page"},{"location":"scores/#DistrictScore","page":"Score Types","title":"DistrictScore","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"This score works best when you're interested in tracking a statistic for each district for all plans in the chain. For example, you might want to know the Polsby-Popper score for each district at every step of the chain.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"DistrictScore","category":"page"},{"location":"scores/#GerryChain.DistrictScore","page":"Score Types","title":"GerryChain.DistrictScore","text":"DistrictScore(name::Union{String, Missing}\n              score_fn::Function)\n\nA DistrictScore takes a user-supplied function that returns some quantity of interest given the nodes in a given district. The signature of score_fn should be as follows:     score_fn(graph::BaseGraph, district_nodes::BitSet, district::int)\n\n\n\n\n\n","category":"type"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"The example below illustrates a simple example of setting up a DistrictScore. Perhaps somehow you find yourself interested in computing the number of edges within a district.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"function num_edges_within_dist(graph::BaseGraph,\n                               district_nodes::BitSet,\n                               district::Int)\n    \"\"\" Computes the number of edges within each district of the plan.\n        Arguments:\n            graph:          The underlying BaseGraph\n            district_nodes: A Set of nodes in district `district`. Each node\n                            is represented as an Int.\n            district:       Int representing the district\n    \"\"\"\n    all_edges = []\n    for node in district_nodes, neighbor in graph.neighbors[node]\n        if neighbor in district_nodes\n            edge = graph.adj_matrix[node, neighbor]\n            push!(all_edges, edge)\n        end\n    end\n    return length(unique(all_edges))\nend\n\n# instantiate this score\nDistrictScore(\"edges_within_dist\", num_edges_within_dist)","category":"page"},{"location":"scores/#PlanScore","page":"Score Types","title":"PlanScore","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"This type of score is suited to statistics that are evaluated on an entire plan. For example, the number of districts won by a party for a given plan would be a PlanScore.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"PlanScore","category":"page"},{"location":"scores/#GerryChain.PlanScore","page":"Score Types","title":"GerryChain.PlanScore","text":"PlanScore(name::Union{String, Missing},\n          score_fn::Function)\n\nA PlanScore takes a user-supplied function that returns some quantity of interest given a BaseGraph and corresponding Partition object.\n\nThe signature of score_fn should be as follows:     score_fn(graph::BaseGraph, partition::Partition)\n\n\n\n\n\n","category":"type"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Below we illustrate a few examples on how to construct a PlanScore:","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"function num_max_blocks(graph::BaseGraph,\n                        partition::Partition)\n    \"\"\" Returns the maximum number of blocks in each district.\n        This function assumes that the nodes in `graph` are blocks.\n    \"\"\"\n    return maximum([length(nodes) for nodes in partition.dist_nodes])\nend\n\nfunction higher_num_cut_edges_than_parent(graph::BaseGraph,\n                                          partition::Partition)\n    \"\"\" Returns True if `partition` has a higher number of cut edges than the\n        previous plan, False otherwise.\n    \"\"\"\n    if partition.parent isa Partition & partition.num_cut_edges > partition.parent.num_cut_edges\n        return True\n    end\n    return False\nend\n\n# how to formulate these scores\nPlanScore(\"num_max_blocks\", num_max_blocks)\nPlanScore(\"higher_num_cut_edges_than_parent\", higher_num_cut_edges_than_parent)","category":"page"},{"location":"scores/#CompositeScore","page":"Score Types","title":"CompositeScore","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"This might be the most difficult type of score to wrap one's mind around. CompositeScores are best when you have a series of scores with some shared state or rely on the same computation. They allow you to \"group\" scores together. For example, we use CompositeScores for Elections, since almost all election-related scores rely on vote counts and vote shares.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"CompositeScore","category":"page"},{"location":"scores/#GerryChain.CompositeScore","page":"Score Types","title":"GerryChain.CompositeScore","text":"CompositeScore(name::String,\n               scores::Array{S,1}) where {S<:AbstractScore} # should be other AbstractScores\n\nA CompositeScore is just a group of scores that are run in sequence. CompositeScores are especially useful when the score functions depend upon/modify some shared state.\n\n\n\n\n\n","category":"type"},{"location":"scores/#Built-In-Score-Functions","page":"Score Types","title":"Built-In Score Functions","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Currently only one score function comes built-in with GerryChain, and it is the number of cut-edges in the plan.","category":"page"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"num_cut_edges","category":"page"},{"location":"scores/#GerryChain.num_cut_edges","page":"Score Types","title":"GerryChain.num_cut_edges","text":"num_cut_edges(name::String)::PlanScore\n\nReturns a PlanScore that tracks the number of cut edges in a particular plan.\n\n\n\n\n\n","category":"function"},{"location":"scores/#A-little-more-detail-on-score-functions","page":"Score Types","title":"A little more detail on score functions","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Why do we differentiate between the different types of scores? The answer boils down to efficiency. Recall that each plan in the chain (whether it is uses   ReCom proposals or Flip proposals) only differs from the previous plan by 2 districts. This means we can save space / eliminate redundant computation by only re-calculating district-level scores on the districts that were changed. However, for plan-level scores, we always have to re-run the score function on the entire partition.","category":"page"},{"location":"scores/#Other-Score-Functions","page":"Score Types","title":"Other Score Functions","text":"","category":"section"},{"location":"scores/","page":"Score Types","title":"Score Types","text":"Modules = [GerryChain]\nPages   = [\"scores.jl\"]\nPrivate = false\nFilter = t -> t ∉ [DistrictAggregate, DistrictScore, PlanScore, CompositeScore,\n                   num_cut_edges, get_score_values, save_scores_to_csv,\n                   save_scores_to_json, get_scores_at_step, ChainScoreData]","category":"page"},{"location":"scores/#GerryChain.coerce_aggregated_attributes!-Union{Tuple{S}, Tuple{BaseGraph,Array{S,1}}} where S<:AbstractScore","page":"Score Types","title":"GerryChain.coerce_aggregated_attributes!","text":"coerce_aggregated_attributes!(graph::BaseGraph,\n                              scores::Array{S, 1}) where {S<:AbstractScore}\n\nCoerces DistrictAggregate attributes in scores to be Floats if they are Strings.\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.eval_score_on_district-Tuple{BaseGraph,Partition,DistrictAggregate,Int64}","page":"Score Types","title":"GerryChain.eval_score_on_district","text":"eval_score_on_district(graph::BaseGraph,\n                       partition::Partition,\n                       score::DistrictAggregate,\n                       district::Int)::Number\n\nEvaluates a DistrictAggregate score on the nodes in a particular district.\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.eval_score_on_district-Tuple{BaseGraph,Partition,DistrictScore,Int64}","page":"Score Types","title":"GerryChain.eval_score_on_district","text":"eval_score_on_district(graph::BaseGraph,\n                       partition::Partition,\n                       score::DistrictScore,\n                       district::Int)\n\nEvaluates a user-supplied DistrictScore function on the nodes in a particular district.\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,CompositeScore}","page":"Score Types","title":"GerryChain.eval_score_on_partition","text":"eval_score_on_partition(graph::BaseGraph,\n                        partition::Partition,\n                        composite::CompositeScore)\n\nEvaluates the user-supplied functions in the CompositeScore scores array on each of the districts in the partition.\n\nReturns an Dict of the form:\n\n{\n    # District-level scores\n    d\\_score₁.name :     [a₁, a₂, ..., aᵢ]\n        ...\n    d\\_scoreᵤ.name :     [b₁, b₂, ..., bᵢ]\n    # Partition-level scores\n    p\\_score₁.name :     c,\n        ...\n    p\\_scoreᵥ.name :     d,\n}\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,PlanScore}","page":"Score Types","title":"GerryChain.eval_score_on_partition","text":"eval_score_on_partition(graph::BaseGraph,\n                        partition::Partition,\n                        score::PlanScore)\n\nEvaluates a user-supplied PlanScore function on the entire partition.\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.eval_score_on_partition-Tuple{BaseGraph,Partition,Union{DistrictAggregate, DistrictScore}}","page":"Score Types","title":"GerryChain.eval_score_on_partition","text":"Evaluates a user-supplied DistrictScore function or DistrictAggregate score on  all districts in an entire plan.\n\nReturns an array of the form [a₁, a₂, ..., aᵢ], where i is the number of districts in the plan.\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.score_initial_partition-Union{Tuple{S}, Tuple{BaseGraph,Partition,Array{S,1}}} where S<:AbstractScore","page":"Score Types","title":"GerryChain.score_initial_partition","text":"score_initial_partition(graph::BaseGraph,\n                        partition::Partition,\n                        scores::Array{S, 1}) where {S<:AbstractScore}\n\nReturns a dictionary of scores for the initial partition. The dictionary has the following form (where n is the number of districts, u is the number of district-level scores, v is the number of partition-level scores, and i is the number of composite scores):\n\n{\n    # District-level scores\n    d\\_score₁.name :     [a₁, a₂, ..., aᵤ]\n        ...\n    d\\_scoreᵤ.name :     [b₁, b₂, ..., bᵤ]\n    # Partition-level scores\n    p\\_score₁.name :     c,\n        ...\n    p\\_scoreᵥ.name :     d,\n    # Composite scores\n    c\\_score₁.name :\n        {\n            c\\_score₁.scores[1].name :     ...\n                ...\n        }\n        ...\n    c\\_scoreᵢ.name :\n        {\n            ...\n        }\n}\n\n\n\n\n\n","category":"method"},{"location":"scores/#GerryChain.score_partition_from_proposal-Union{Tuple{S}, Tuple{BaseGraph,Partition,GerryChain.AbstractProposal,Array{S,1}}} where S<:AbstractScore","page":"Score Types","title":"GerryChain.score_partition_from_proposal","text":"score_partition_from_proposal(graph::BaseGraph,\n                              partition::Partition,\n                              proposal::AbstractProposal,\n                              scores::Array{S, 1}) where {S<:AbstractScore}\n\nReturns a Dictionary of\n\n(a) updated district-level scores for districts that were altered\n\nafter proposal was accepted,\n\n(b) partition-level scores, and\n\n(c) composite scores, that may be comprised of scores from (a) or (b).\n\nFor example, suppose district 4's new White population is 43 and the new Sen2010_Dem population is 62, district 8's new White population is 22 and new Sen2010_Dem population is 66. The Δ scores would look like:\n\n    {\n        \"num_cut_edges\" : partition.num\\_cut\\_edges,\n        \"dists\"         : (5, 8),\n        \"White\"         : [43, 22],\n        \"Sen2010_Dem\"   : [62, 66],\n    }\n\n\n\n\n\n","category":"method"},{"location":"graph/#BaseGraph","page":"BaseGraph","title":"BaseGraph","text":"","category":"section"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"How do we \"load\" a map into GerryChain? We start by initializing a BaseGraph object from either a .json or .shp file.","category":"page"},{"location":"graph/#Properties","page":"BaseGraph","title":"Properties","text":"","category":"section"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"Once you initialize a BaseGraph, you can access the following properties from it:","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"BaseGraph Properties Description\nnum_nodes (Int) Number of nodes in the BaseGraph\nnum_edges (Int) Number of edges in the BaseGraph\ntotal_pop (Int) Total Population in the BaseGraph\npopulations Array{Int, 1} An array of populations at the node level, where the i'th index of the array is the population of the i'th node\nadj_matrix SparseMatrixCSC{Int, Int} A sparse adjacency matrix of the graph, where an edge exists between nodes i and j if adj_matrix[i,j] != 0. The value at adj_matrix[i,j] is the edge id of the edge that connects nodes i and j.\nedge_src Array{Int, 1} An array of length(numedges) where `edgesrc[i]is the source of the edgei`.\nedge_dst Array{Int, 1} An array of length(numedges) where `edgedst[i]is the destination of the edgei`.\nneighbors Array{Array{Int64,1},1} An array of arrays, where neighbors[i] holds a list of all the neighbors of node i\nsimple_graph SimpleGraph A SimpleGraph object from the LightGraphs library\nattributes Array{Dict{String, Any}} An array of dictionaries where attributes[i] holds the attributes of node i","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"BaseGraph","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"Order = [:type, :function]\nPages   = [\"graph.md\"]","category":"page"},{"location":"graph/#Initializing-a-BaseGraph","page":"BaseGraph","title":"Initializing a BaseGraph","text":"","category":"section"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"A BaseGraph can be initialized in the following way:","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"BaseGraph","category":"page"},{"location":"graph/#GerryChain.BaseGraph","page":"BaseGraph","title":"GerryChain.BaseGraph","text":"BaseGraph(filepath::AbstractString,\n          pop_col::AbstractString;\n          adjacency::String=\"rook\")::BaseGraph\n\nBuilds the BaseGraph object. This is the underlying network of our districts, and its properties are immutable i.e they will not change from step to step in our Markov Chains.\n\nArguments:\n\nfilepath:       A path to a .json or .shp file which contains the                 information needed to construct the graph.\npop_col:        the node attribute key whose accompanying value is the                 population of that node\nadjacency:      (Only used if the user specifies a filepath to a .shp                 file.) Should be either \"queen\" or \"rook\"; \"rook\" by default.\n\n\n\n\n\n","category":"type"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"If you initialize a BaseGraph from a .shp file, make sure that there is another file of the same name with a .dbf extension in the same folder! This is because the .shp file provides the geometry of the regions of interest, while the .dbf provides information about each region's attributes - e.g., the total number of votes cast or the percentage of Black voters.","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"If you initialize a BaseGraph from a .json file, GerryChain expects the .json file to be generated by the Graph.to_json() function of the Python implementation of GerryChain. We assume that the JSON file has the structure of a dictionary where","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"(1) the key \"nodes\" yields an array of dictionaries of node attributes,","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"(2) the key \"adjacency\" yields an array of edges (represented as dictionaries), and","category":"page"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"(3) the key \"id\" within the edge dictionary indicates the destination node of the edge.","category":"page"},{"location":"graph/#API","page":"BaseGraph","title":"API","text":"","category":"section"},{"location":"graph/","page":"BaseGraph","title":"BaseGraph","text":"Modules = [GerryChain]\nPages   = [\"graph.jl\"]\nPrivate = false\nFilter = t -> t != BaseGraph","category":"page"},{"location":"graph/#GerryChain.get_attributes-Tuple{Array{Any,1}}","page":"BaseGraph","title":"GerryChain.get_attributes","text":"get_attributes(nodes::Array{Any, 1})\n\nReturns an array of dicts attributes of length length(nodes) where the attributes of the nodes[i] is at attributes[i] as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"graph/#GerryChain.get_subgraph_population-Tuple{BaseGraph,BitSet}","page":"BaseGraph","title":"GerryChain.get_subgraph_population","text":"get_subgraph_population(graph::BaseGraph,\n                        nodes::BitSet)::Int\n\nArguments:\n\ngraph: Underlying graph object\nnodes: A Set of Ints\n\nReturns the population of the subgraph induced by nodes.\n\n\n\n\n\n","category":"method"},{"location":"graph/#GerryChain.induced_subgraph_edges-Tuple{BaseGraph,Array{Int64,1}}","page":"BaseGraph","title":"GerryChain.induced_subgraph_edges","text":"induced_subgraph_edges(graph::BaseGraph,\n                       vlist::Array{Int, 1})::Array{Int, 1}\n\nReturns a list of edges of the subgraph induced by vlist, which is an array of vertices.\n\n\n\n\n\n","category":"method"},{"location":"graph/#GerryChain.weighted_kruskal_mst","page":"BaseGraph","title":"GerryChain.weighted_kruskal_mst","text":"weighted_kruskal_mst(graph::BaseGraph,\n                     edges::Array{Int, 1},\n                     nodes::Array{Int, 1},\n                     weights::Array{Float64, 1},\n                     rng=MersenneTwister(1234))::BitSet\n\nGenerates and returns a minimum spanning tree from the subgraph induced by edges and nodes, using Kruskal's MST algorithm.\n\nNote:\n\nThe graph represents the entire graph of the plan, where as edges and nodes represent only the sub-graph on which we want to draw the MST.\n\nArguments:\n\ngraph: Underlying Graph object\nedges: Array of edges of the sub-graph\nnodes: Set of nodes of the sub-graph\nweights: Array of weights of length(edges) where weights[i] is the          weight of edges[i]\n\nReturns a BitSet of edges that form a mst.\n\n\n\n\n\n","category":"function"},{"location":"saving_results/#Saving-results","page":"Saving Results","title":"Saving results","text":"","category":"section"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Let's say that you've run a chain and want to save the resulting ChainScoreData object to your hard drive, so that you can do analysis of the results at a later time without having to re-run the chain. Below are some options you could pursue to do that.","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Order = [:type, :function]\nPages   = [\"saving_results.md\"]","category":"page"},{"location":"saving_results/#Serialization","page":"Saving Results","title":"Serialization","text":"","category":"section"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"One super simple way to save the results is to use Julia's built-in Serialization library to save the ChainScoreData object. Here's an example:","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"chain_data = recom_chain(...)\nserialize(\"example.jld\", chain_data)","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Then, in order to read back the saved data in another file, just run","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"chain_data = deserialize(\"example.jld\")","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Note that the .jld format is specific to Julia, so you won't be able to deserialize in a script written in another language, like Python or R.","category":"page"},{"location":"saving_results/#Saving-scores-to-CSV","page":"Saving Results","title":"Saving scores to CSV","text":"","category":"section"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"CSV is a common format used to store data. We've written a function called save_scores_to_csv() into GerryChain that makes it super simple to export scores to a CSV format, which can then be read by programs in any language of your choosing. Each row of the CSV will correspond to one state in the chain, while each score corresponds to one or more columns. (District level scores will produce one column for each district. For example: a district-level score called bvap evaluated on plans with 10 districts will generate 10 columns: bvap_1, bvap_2, ...bvap_10.) The order of the rows corresponds to the order of the states visited by the chain. Here's what the function looks like:","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"save_scores_to_csv","category":"page"},{"location":"saving_results/#GerryChain.save_scores_to_csv","page":"Saving Results","title":"GerryChain.save_scores_to_csv","text":"save_scores_to_csv(filename::String,\n                   chain_data::ChainScoreData,\n                   score_names::Array{String,1}=String[])\n\nSave the scores in a CSV file named filename.\n\n\n\n\n\n","category":"function"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Usage","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"# let's say there are 3 districts and 2 steps in the chain\nchain_data = recom_chain(...)\nsave_scores_to_csv(\"data.csv\", chain_data, score_names = [\"cut_edges\", \"vote_count_d\", \"vote_share_d\"]) # 1 plan score, 2 district-level scores","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Resulting CSV","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"cut_edges,vote_count_d_1,vote_count_d_2,vote_count_d_3,vote_share_d_1,vote_share_d_2,vote_share_d_3\n5,2,4,4,0.2,0.4,0.4\n6,3,5,2,0.3,0.5,0.2","category":"page"},{"location":"saving_results/#Saving-scores-to-JSON","page":"Saving Results","title":"Saving scores to JSON","text":"","category":"section"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"save_scores_to_json","category":"page"},{"location":"saving_results/#GerryChain.save_scores_to_json","page":"Saving Results","title":"GerryChain.save_scores_to_json","text":"save_scores_to_json(filename::String,\n                    chain_data::ChainScoreData,\n                    score_names::Array{String,1}=String[])\n\nSave the scores in a JSON file named filename.\n\n\n\n\n\n","category":"function"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"Usage","category":"page"},{"location":"saving_results/","page":"Saving Results","title":"Saving Results","text":"chain_data = recom_chain(graph, partition, pop_constraint, 10, scores)\nsave_scores_to_json(\"test.json\", chain_data) # by default will save all scores in the chain\n# alternatively, save_scores_to_json(\"test.json\", chain_data, [\"names\", \"of\", \"desired\", \"scores\"])","category":"page"},{"location":"partition/#Partitions","page":"Partition","title":"Partitions","text":"","category":"section"},{"location":"partition/","page":"Partition","title":"Partition","text":"A partition is a fancy word for a districting plan. It assigns every node in the graph (e.g. precincts, counties, blocks) with a particular label (e.g., Congressional district). We need an initial partition because it will serve as the \"seed\" plan for our Markov chain.","category":"page"},{"location":"partition/#Properties","page":"Partition","title":"Properties","text":"","category":"section"},{"location":"partition/","page":"Partition","title":"Partition","text":"The Partition, once constructed, has the following properties:","category":"page"},{"location":"partition/","page":"Partition","title":"Partition","text":"Partition Properties Description\nnum_dists (Int) Number of districts in the Partition\nnum_cut_edges (Int) Number of cut edges in the Partition\nassignments Array{Int, 1} An array of length(num_nodes) where assignments[i] is the assignment of node i\ndist_populations (Array{Int, 1} An array of length(numdistricts) where `distpopulations[i]is the population of districti`\ncut_edges Array{Int, 1} An array of length(numedges) where `cutedges[i]is 1 if edgei` is a cut edge, and 0 otherwise\ndist_adj SparseMatrixCSC{Int, Int} An adjacency matrix of size length(numdistricts) x length(numdistricts) where districts i and j are adjacent if dist_adj[i, j] is the number of cut-edges between districts i and j. If the districts are not adjacent, this value is 0\ndist_nodes BitSet An array of sets where dist_nodes[i] is the set of all district nodes of district i\nparent Union{Partition, Nothing} A field that holds the parent of the Partition. This value is Nothing in the first step of the chain when the Partition has no parent","category":"page"},{"location":"partition/","page":"Partition","title":"Partition","text":"Partition","category":"page"},{"location":"partition/","page":"Partition","title":"Partition","text":"Order = [:type, :function]\nPages   = [\"partition.md\"]","category":"page"},{"location":"partition/#Initializing-a-Partition","page":"Partition","title":"Initializing a Partition","text":"","category":"section"},{"location":"partition/","page":"Partition","title":"Partition","text":"A Partition can be initialized in the following way:","category":"page"},{"location":"partition/","page":"Partition","title":"Partition","text":"Partition","category":"page"},{"location":"partition/#GerryChain.Partition","page":"Partition","title":"GerryChain.Partition","text":"Partition(graph::BaseGraph,\n          assignment_col::AbstractString)::Partition\n\nPartition represents a partition of the nodes of the graph. It contains plan-specific information that will change each time we change our plan.\n\nArguments:\n\ngraph:          BaseGraph object that has the underlying network                 structure of the plan.\nassignment_col: the key denoting the district assignment at the                 node level\n\n\n\n\n\n","category":"type"},{"location":"partition/#API","page":"Partition","title":"API","text":"","category":"section"},{"location":"partition/","page":"Partition","title":"Partition","text":"Modules = [GerryChain]\nPages   = [\"partition.jl\"]\nPrivate = false\nFilter = t -> t != Partition","category":"page"},{"location":"partition/#GerryChain.get_district_adj_and_cut_edges-Tuple{BaseGraph,Array{Int64,1},Int64}","page":"Partition","title":"GerryChain.get_district_adj_and_cut_edges","text":"get_district_adj_and_cut_edges(graph::BaseGraph,\n                               assignments::Array{Int, 1},\n                               num_districts::Int)\n\nReturns:\n\ndistrict_adj: a num_districts x num_districts matrix where the               elements are the number of cut edges between the districts\ncut_edges:    an Array of size(num_edges) where i'th element is 1               if edge i is a cut_edge, 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"partition/#GerryChain.get_district_nodes-Tuple{Array{Int64,1},Int64,Int64}","page":"Partition","title":"GerryChain.get_district_nodes","text":"get_district_nodes(assignments::Array{Int, 1},\n                   num_nodes::Int,\n                   num_districts::Int)::Array{Set{Int}, 1}\n\nReturns an Array of Sets district_nodes where the nodes of the i'th district will be at district_nodes[i] as a Set.\n\n\n\n\n\n","category":"method"},{"location":"partition/#GerryChain.get_district_populations-Tuple{Array{Int64,1},Array{Int64,1},Int64,Int64}","page":"Partition","title":"GerryChain.get_district_populations","text":"get_district_populations(assignments::Array{Int, 1},\n                         populations::Array{Int, 1},\n                         num_nodes::Int,\n                         num_districts::Int)::Array{Int, 1}\n\nReturns an Array of populations dist_pops where the population of the i'th district is at dist_pops[i].\n\n\n\n\n\n","category":"method"},{"location":"partition/#GerryChain.update_partition_adjacency-Tuple{Partition,BaseGraph}","page":"Partition","title":"GerryChain.update_partition_adjacency","text":"update_partition_adjacency(partition::Partition,\n                           graph::BaseGraph)\n\nUpdates the district adjacency matrix and cut edges to reflect the partition's assignments for each node.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A plan is only valid if it satisfies certain constraints. There are two main constraints that are implemented in GerryChain and are common in the definition of districting plans:","category":"page"},{"location":"constraints/#PopulationConstraint","page":"Constraints","title":"PopulationConstraint","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"PopulationConstraint","category":"page"},{"location":"constraints/#GerryChain.PopulationConstraint","page":"Constraints","title":"GerryChain.PopulationConstraint","text":"PopulationConstraint(graph::BaseGraph,\n                     partition::Partition,\n                     tolerance::Float64)::PopulationConstraint\n\nInitializes a PopulationConstraint that stores the minimum and maximum populations a district in a partition could have within tolerance.\n\nReturns the PopulationConstraint object.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#ContiguityConstraint","page":"Constraints","title":"ContiguityConstraint","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"ContiguityConstraint","category":"page"},{"location":"constraints/#GerryChain.ContiguityConstraint","page":"Constraints","title":"GerryChain.ContiguityConstraint","text":"ContiguityConstraint()\n\nInitializes and returns a ContiguityConstraint object.\n\n\n\n\n\n","category":"type"},{"location":"getting_started/#Getting-started-with-a-chain","page":"Getting started with a chain","title":"Getting started with a chain","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"We'll start by showing a block of code that runs a simple chain, and then we'll break down what each section is doing afterwards. If you want to run this code, you can copy and paste the provided code into a file (for example, main.jl) at the root directory of the repository. Then, you can run it by navigating to the repository and running julia main.jl from the commmand line.","category":"page"},{"location":"getting_started/#Code","page":"Getting started with a chain","title":"Code","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"using GerryChain\n\nSHAPEFILE_PATH = \"./PA_VTD.json\"\nPOPULATION_COL = \"TOT_POP\"\nASSIGNMENT_COL = \"538GOP_PL\"\n\n# Initialize graph and partition\ngraph = BaseGraph(SHAPEFILE_PATH, POPULATION_COL)\npartition = Partition(graph, ASSIGNMENT_COL)\n\n# Define parameters of chain (number of steps and population constraint)\npop_constraint = PopulationConstraint(graph, partition, 0.02)\nnum_steps = 10\n\n# Initialize Election of interest\nelection = Election(\"SEN10\", [\"SEN10D\", \"SEN10R\"], partition.num_dists)\n# Define election-related metrics and scores\nelection_metrics = [\n    vote_count(\"count_d\", election, \"SEN10D\"),\n    efficiency_gap(\"efficiency_gap\", election, \"SEN10D\"),\n    seats_won(\"seats_won\", election, \"SEN10D\"),\n    mean_median(\"mean_median\", election, \"SEN10D\")\n]\nscores = [\n        DistrictAggregate(\"presd\", \"PRES12D\"),\n        ElectionTracker(election, election_metrics)\n]\n\n# Run the chain\nprintln(\"Running 10-step ReCom chain...\")\nchain_data = recom_chain(graph, partition, pop_constraint, num_steps, scores)\n\n# Get values of all scores at the 10th state of the chain\nscore_dict = get_scores_at_step(chain_data, 10)\n# Get all vote counts for each state of the chain\nvote_counts_arr = get_score_values(chain_data, \"count_d\")","category":"page"},{"location":"getting_started/#Section-by-section-overview","page":"Getting started with a chain","title":"Section-by-section overview","text":"","category":"section"},{"location":"getting_started/#Reading-in-the-graph-and-partition","page":"Getting started with a chain","title":"Reading in the graph and partition","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"graph = BaseGraph(SHAPEFILE_PATH, POPULATION_COLL)\npartition = Partition(SHAPEFILE_PATH, graph, POPULATION_COL, ASSIGNMENT_COL)","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"We read in the graph from a shapefile, which is a file that contains a lot of information about the various precincts in our area of interest. It contains information such as which precincts are adjacent to each other, the voting totals of each precinct in various elections, demographic characteristics of each precinct, etc. This information is stored in the graph object. Imagine the graph object as storing the \"ground truth\" about the precincts in an area. We pass in the name of the column in the shapefile that contains the population of each precinct as well as the name of the column that contains the initial assignment of precincts to districts.","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"On the other hand, the partition object is designed to do just that: contain many-to-one mapping of nodes in our graph to districts. Partition is just a fancy way of saying \"assigning places to districts\" - in other words, a districting plan! The Markov chain has to start somewhere, so the initial partition is the districting plan at the start of the chain. We pass in the same additional arguments (name of the population column and name of the assignment column), because we need to know (a) how many people are in each district and (b) the initial plan.","category":"page"},{"location":"getting_started/#Define-number-of-steps-and-population-constraint","page":"Getting started with a chain","title":"Define number of steps and population constraint","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"pop_constraint = PopulationConstraint(graph, partition, 0.02)\nnum_steps = 10","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"We will (eventually) pass in the population constraint to our chain as a way to ensure that the plans generated by the chain do not create districts that have unacceptable levels of population imbalance. Here, we are allowing each district to have a population that deviates from a maximum of 2% from the total population divided by the number of districts. We also declare that the number of steps that will be taken by the chain is 10. Since there are 10 steps that will be taken, we will generate 10 new plans. That means the chain is composed of a total of 11 plans - 1 initial plan and 10 generated plans.","category":"page"},{"location":"getting_started/#Initialize-Election-of-interest","page":"Getting started with a chain","title":"Initialize Election of interest","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"election = Election(\"SEN10\", [\"SEN10D\", \"SEN10R\"], partition.num_dists)","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"Oftentimes, a key part of an analysis that uses GerryChain is measuring the election outcomes across our different districting plans. We first define an Election object, which we pass a name, the columns in our shapefile that correspond to the vote counts for each party, and the number of districts in the plan.","category":"page"},{"location":"getting_started/#Define-scores","page":"Getting started with a chain","title":"Define scores","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"election_metrics = [\n    vote_count(\"count_d\", election, \"SEN10D\"),\n    efficiency_gap(\"efficiency_gap\", election, \"SEN10D\"),\n    seats_won(\"seats_won\", election, \"SEN10D\"),\n    mean_median(\"mean_median\", election, \"SEN10D\")\n]\nscores = [\n        DistrictAggregate(\"presd\", \"PRES12D\"),\n        ElectionTracker(election, partisan_metrics)\n]","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"Every time our chain generates a new proposal, we might want to run some functions that measure important aspects of the new plan. What would election outcomes be under this plan? What are the total populations of White or Black individuals in each district? What is the mean-median score of this plan? These evaluative metrics are what we call \"scores.\" Broadly, there are two types of scores: DistrictScores and PlanScores. DistrictScores return some value for each district in the plan (for example, the difference between white and Black populations in each district). PlanScores return one value for the entire plan (such as the number of cut edges). The DistrictAggregate score defined above is a special type of DistrictScore which simply sums all of the Democratic votes in the 2012 election for each district.","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"In this code block, note that we start by defining a set of partisan metrics, including the efficiency gap, seats won by a particular party, and the mean-median score, which then gets passed to the ElectionTracker. An ElectionTracker is a special type of score called a CompositeScore, which runs a set of score functions that are related. In this case, grouping partisan metrics into the ElectionTracker helps the chain run more efficiently; once a new plan is generated, it re-calculates the vote counts in each district, and then all of the partisan metric scores can be run on the updated vote counts (rather than vote counts being re-calculated for every partisan metric). If no partisan metrics are passed to the ElectionTracker, then it simply keeps track of vote counts and vote shares for each party in each district.","category":"page"},{"location":"getting_started/#Running-the-chain","page":"Getting started with a chain","title":"Running the chain","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"println(\"Running 10-step ReCom chain...\")\nchain_data = recom_chain(graph, partition, pop_constraint, num_steps, scores)","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"Now that we've defined our graph, initial plan, population constraint, number of steps, and the score functions, we can run our chain! We pass these arguments to recom_chain to start a Markov chain that uses the ReCom proposal method (which you can read about here). (If you want to use the Flip proposal method instead, you can swap out recom_chain for flip_chain pretty easily, although there are some minor tweaks you would have to make).","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"The recom_chain method returns a ChainScoreData object which we can then query to get the value of any score(s) at a specific step of the chain (using get_scores_at_step) or all values of a particular score throughout the entire chain (using get_score_values).","category":"page"},{"location":"getting_started/#Retrieving-values-of-scores","page":"Getting started with a chain","title":"Retrieving values of scores","text":"","category":"section"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"# Get values of all scores at the 10th state of the chain\nscore_dict = get_scores_at_step(chain_data, 10)\n# Get all vote counts for each state of the chain\nvote_counts_arr = get_score_values(chain_data, \"count_d\")","category":"page"},{"location":"getting_started/","page":"Getting started with a chain","title":"Getting started with a chain","text":"The chain_data object returned by recom_chain can be queried to get the values of scores, as shown above.","category":"page"},{"location":"accept/#Acceptance-Functions","page":"Acceptance Functions","title":"Acceptance Functions","text":"","category":"section"},{"location":"accept/","page":"Acceptance Functions","title":"Acceptance Functions","text":"Acceptance functions are user-defined functions passed to recom_chain/flip_chain that are used to evaluate a proposal for the next state in a chain and generate a probability for \"accepting\" the new plan. If the plan is rejected, then the step in the Markov chain is considered to be a \"self-loop.\" Note that acceptance functions are conceptually different from constraints, which are hard, deterministic requirements on every plan in a chain. If a plan is generated that does not satisfy a constraint, then new plans are generated until the constraint is satisfied, at which point the chain makes a step to the constraint-satisfying plan. Contrast this to acceptance functions, which generate probabilities for accepting a plan, and when a plan is not accepted, produce a self-loop in the chain.","category":"page"},{"location":"accept/","page":"Acceptance Functions","title":"Acceptance Functions","text":"Practically, acceptance functions are expected to accept a Partition object and return a probability between 0 and 1. The reason for this is that acceptance functions are really most useful in cases like the Metropolis-Hasting algorithm and \"burning in\". If, for some reason, you need a deterministic acceptance function, you can simply have it return 0 or 1.","category":"page"},{"location":"accept/","page":"Acceptance Functions","title":"Acceptance Functions","text":"Order = [:type, :function]\nPages   = [\"accept.md\"]","category":"page"},{"location":"accept/","page":"Acceptance Functions","title":"Acceptance Functions","text":"The following is a sample acceptance function included in the GerryChain library:","category":"page"},{"location":"accept/","page":"Acceptance Functions","title":"Acceptance Functions","text":"always_accept","category":"page"},{"location":"accept/#GerryChain.always_accept","page":"Acceptance Functions","title":"GerryChain.always_accept","text":"always_accept(partition::Partition)\n\nAccepts partition with probability 1.\n\n\n\n\n\n","category":"function"},{"location":"accept/#API","page":"Acceptance Functions","title":"API","text":"","category":"section"},{"location":"accept/","page":"Acceptance Functions","title":"Acceptance Functions","text":"Modules = [GerryChain]\nPages   = [\"accept.jl\"]\nPrivate = false\nFilter = t -> t != always_accept","category":"page"},{"location":"accept/#GerryChain.satisfies_acceptance_fn-Tuple{Partition,Function}","page":"Acceptance Functions","title":"GerryChain.satisfies_acceptance_fn","text":"satisfies_acceptance_fn(partition::Partition,\n                        acceptance_fn::Function)::Bool\n\nDetermines whether a partition should be accepted, according to the user-specified acceptance function. Acceptance function must return a valid probability in [0, 1], and satisfies_acceptance_fn will use this probability to determine whether the partition should be accepted.\n\nArguments:\n\npartition:      Partition. Should have a valid \"parent\" field                 so the acceptance function can compare the new                 partition to the previous partition, if necessary.\nacceptance_fn:  A user-specified function that should take                 partition as an argument and return a probability                 in the range [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Data-visualization","page":"Plotting","title":"Data visualization","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"After running a chain, it's common to want to create some data visualizations that summarize various statistics of interest across plans in the chain (e.g., a compactness score, party vote share by district, etc.). As part of the GerryChainJulia library, we use PyPlot.jl to create some functions that will generate some common types of graphs.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Order = [:type, :function]\nPages   = [\"plotting.md\"]","category":"page"},{"location":"plotting/#score_boxplot()","page":"Plotting","title":"score_boxplot()","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Boxplots can be helpful for visualizing the \"typical\" range of values for a statistic of interest for all the plans in the chain. For example, users interested to know whether \"cracking and packing\" has occurred might compare the percentage of minority voters in each district in an enacted plan overlaid on a set of boxplots representing the typical range of percentage of minority voters for plans generated by the chain. Users can generate boxplots for any score of interest. If the score is a district-wide score (e.g., percentage of white voters in each district), then there will be multiple boxplots shown in the same figure, with each boxplot representing the range of scores for a particular district. If the score is a plan-wide score, then there will be one boxplot in the figure.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"score_boxplot","category":"page"},{"location":"plotting/#GerryChain.score_boxplot","page":"Plotting","title":"GerryChain.score_boxplot","text":"score_boxplot(score_values::Array{S, 2};\n              sort_by_score::Bool=true,\n              label::String=\"GerryChain\",\n              comparison_scores::Array=[],\n              ax::Union{Nothing, PyPlot.PyObject}=nothing) where {S<:Number}\n\nProduces a graph with multiple matplotlib box plots for the values of scores throughout the chain. Intended for use with district-level scores (DistrictAggregate, DistrictScore).\n\nArguments:\n\nscore_values        : A 2-dimensional array of score values with                       dimension (n x d), where n is the number of                       states in the chain and d is the number of                       districts\nsortbyscore       : Whether we should order districts by median                       of score value.\nlabel               : Legend key for the GerryChain boxplots. Only shown                       if there are scores from other plans passed in                       as reference points.\ncomparison_scores   : A list of Tuples that is passed in if the user                       would like to compare the per-district scores                       of a particular plan with the GerryChain results                       on the same graph. The list of tuples should                       have the structure [(l₁, scores₁), ... , (lᵤ, scoresᵤ)],                       where lᵢ is a label that will appear on the                       legend and scoresᵢ is an array of length d,                       where d is the number of districts. Each                       element of the tuple should be of type                       Tuple{String, Array{S, 1}}. Example:                         [                           (name₁, [v₁, v₂, ... , vᵤ]),                           ...                           (nameₓ, [w₁, w₂, ... , wᵤ])                         ], where there are x comparison plans and u                       districts.\nax                  : A PyPlot (matplotlib) Axis object\n\nReturns a MatPlotLib Axis object with the boxplot.\n\n\n\n\n\nscore_boxplot(score_values::Array{S, 1};\n              label::String=\"GerryChain\",\n              comparison_scores::Array=[],\n              ax::Union{Nothing, PyPlot.PyObject}=nothing) where {S<:Number}\n\nProduces a single matplotlib box plot for the values of scores throughout the chain. Intended for use with plan-level scores.\n\nArguments:\n\nscore_values        : A 1-dimensional array of score values of                       length n, where n is the number of states in                       the chain.\nlabel               : Legend key for the GerryChain boxplots. Only shown                       if there are scores from other plans passed in                       as reference points.\ncomparison_scores   : A list of Tuples that is passed in if the user                       would like to compare the score of a particular                       plan with the GerryChain boxplot on the same graph.                       The list of tuples should have the structure                       [(l₁, score₁), ... , (lᵤ, scoreᵤ)], where lᵢ                       is a label that will appear on the legend and                       scoreᵢ is the value of the plan-wide score                       for the comparison plan.\nax                  : A PyPlot (matplotlib) Axis object\n\nReturns a MatPlotLib Axis object with the boxplot.\n\n\n\n\n\nscore_boxplot(chain_data::ChainScoreData,\n              score_name::String; kwargs...)\n\nCreates a graph with boxplot(s) of the values of scores throughout the chain.\n\nArguments:\n\nchain_data  : ChainScoreData object that contains the values of scores at               every step of the chain\nscore_name  : name of the score (i.e., the name field of an AbstractScore)\nkwargs      : Optional arguments, including label, comparison_scores, and               sort_by_score (the latter should only be passed for               district-level scores).\n\nReturns a MatPlotLib Axis object with the boxplot.\n\n\n\n\n\n","category":"function"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Usage","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# run chain\nchain_data = recom_chain(...)\n\n# graph results and compare to enacted plan!\n# the length of `plan1_dshare` and `plan2_dshare` should be equal to the total # of districts\nplan1_dshare = [...]\nplan2_dshare = [...]\nscore_boxplot(chain_data, \"dem_vote_share\", comparison_scores=[(\"plan1\", plan1_dshare), (\"plan2\", plan2_dshare)])\n# without comparison scores:\n# score_boxplot(chain_data, \"dem_vote_share\")\n\n# if you want to edit anything about the default plot, you can simply use plt\nplt.ylabel(\"Democratic vote share\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Example of generated plot","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: boxplot)","category":"page"},{"location":"plotting/#score_histogram()","page":"Plotting","title":"score_histogram()","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"This function allows users to easily create histogram graphs of a (plan-level) score of interest (e.g., the number of cut edges, the number of seats won by a particular party, etc.) (Unlike the score_boxplot function, this function cannot be used on district-level scores.) Similar to score_boxplot, you can also pass in \"comparison scores\" to visualize where a particular value of a score lies in relation to the histogram of values observed during the process of the chain.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"score_histogram","category":"page"},{"location":"plotting/#GerryChain.score_histogram","page":"Plotting","title":"GerryChain.score_histogram","text":"score_histogram(score_values::Array{S, 1};\n                comparison_scores::Array=[],\n                bins::Union{Nothing, Int, Vector}=nothing,\n                range::Union{Nothing, Tuple}=nothing,\n                density::Bool=false,\n                rwidth::Union{Nothing, T}=nothing,\n                ax::Union{Nothing, PyPlot.PyObject}=nothing) where {S<:Number, T<:Number}\n\nCreates a graph with histogram of the values of a score throughout the chain. Only applicable for scores of type PlanScore.\n\nArguments:\n\nscore_values        : A 1-dimensional array of score values of length n,                       where n is the number of states in the chain.\ncomparison_scores   : A list of Tuples that is passed in if the user                       would like to compare core of a particular                       plan with the GerryChain histogram on the same                       figure. The list of tuples should have the                       structure [(l₁, score₁), ... , (lᵤ, scoreᵤ)],                       where lᵢ is a label that will appear on the                       legend and scoreᵢ is the value of the plan-wide                       score for the comparison plan.\nax                  : A PyPlot (matplotlib) Axis object\n\nReturns a MatPlotLib Axis object with the histogram.\n\n\n\n\n\nscore_histogram(chain_data::ChainScoreData,\n                score_name::String; kwargs...)\n\nCreates a graph with histogram of the values of a score throughout the chain. Only applicable for scores of type PlanScore.\n\nArguments:\n\nchain_data  : ChainScoreData object that contains the values of scores at               every step of the chain\nscore_name  : name of the score (i.e., the name field of an AbstractScore)\nkwargs      : Optional arguments, including comparison_scores and other               matplotlib arguments.\n\nReturns a MatPlotLib Axis object with the histogram.\n\n\n\n\n\n","category":"function"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Usage","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# run chain\nchain_data = recom_chain(...)\n\n# graph results and compare to enacted plan!\nscore_histogram(chain_data, \"cut_edges\", comparison_scores=[ (\"enacted\", 21) ]) # if the enacted plan has 21 cut edges\n# score_histogram(chain_data, \"cut_edges\", comparison_scores=[ (\"enacted\", 21) ], bins=3, rwidth=1) # we also support passing in a few arguments that can be passed into matplotlib\n# score_histogram(chain_data, \"cut_edges\") # without any comparison scores\n\n# if user wants to edit anything about the default plot, they can simply use plt\nplt.xlabel(\"efficiency_gap\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Example of generated histogram","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: boxplot)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Code Coverage) (Image: DOI) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the GerryChain Julia! Thank you for taking the time to use and/or learn about our package. If you were looking for the Python wiki, go here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project is actively maintained by the Metric Geometry and Gerrymandering Group and is distributed under the GPL v3.0 license.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to help support the project, please star the repository (Image: STARS) and share it with your colleagues.","category":"page"},{"location":"#What-is-GerryChain?","page":"Home","title":"What is GerryChain?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GerryChain is a package (also, written in Python) for building ensembles of districting plans by using Markov Chain Monte Carlo (MCMC). From the Python GerryChain page: \"The basic workflow is to start with the geometry of an initial plan and generate a large collection of sample plans for comparison. Usually, we will constrain these sampled plans in such a way that they perform at least as well as the initial plan according to traditional districting principles, such as population balance or compactness. Comparing the initial plan to the ensemble provides quantitative tools for measuring whether or not it is an outlier among the sampled plans.\" You can think of each step in the Markov Chain as generating a new districting plan.","category":"page"},{"location":"#What-is-Julia?","page":"Home","title":"What is Julia?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia is a highly-performant, dynamically-typed programming language suitable for scientific and numerical computing. You can see a comparison of performance between Julia and Python performed by NASA here; long story short, Julia tends to be much, much faster than Python. At the same time, Julia has the benefit of \"looking like Python\"; users of the Python GerryChain package will find that GerryChainJulia will feel and look familiar.","category":"page"},{"location":"#*Why*-is-GerryChain-in-Julia?","page":"Home","title":"Why is GerryChain in Julia?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"At a fundamental level, GerryChain exists because it is infeasible to compare an initial plan to the complete universe of possible districting plans for a particular region. (In many cases, there are more possible plans than atoms in the universe!) Through the GerryChain approach, we instead take a \"random walk\" in the universe of possible plans, generating some finite number of plans, to which we can then compare our initial plan. Speeding up the GerryChain computations with Julia means that we can generate a number of plans an order of magnitude greater than what we could achieve with the Python library in the same amount of time, with the intention that the subsequent analysis is more robust.","category":"page"},{"location":"#Citations","page":"Home","title":"Citations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can cite the Recombination algorithm as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{deford2019recombination,\n    title={Recombination: A family of Markov chains for redistricting},\n    author={Daryl DeFord and Moon Duchin and Justin Solomon},\n    year={2019},\n    eprint={1911.05725},\n    archivePrefix={arXiv},\n    primaryClass={cs.CY}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The most up to date citation of the code would be at (Image: DOI).","category":"page"},{"location":"#How-do-I-get-started?","page":"Home","title":"How do I get started?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You'll want to start with setting up your computing environment. Next, you should check out our tutorial on running your first GerryChain! If you wish to contribute to the development of this project, please refer to our contributing guidelines.","category":"page"}]
}
